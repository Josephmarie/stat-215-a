<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2024-09-28">

<title>Lab 2 - Linguistics Data, Stat 215A, Fall 2024</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script><script src="lab2_files/libs/clipboard/clipboard.min.js"></script>
<script src="lab2_files/libs/quarto-html/quarto.js"></script>
<script src="lab2_files/libs/quarto-html/popper.min.js"></script>
<script src="lab2_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="lab2_files/libs/quarto-html/anchor.min.js"></script>
<link href="lab2_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="lab2_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="lab2_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="lab2_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="lab2_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>

<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>


</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
<div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="lab2.pdf"><i class="bi bi-file-pdf"></i>PDF</a></li></ul></div></div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Lab 2 - Linguistics Data, Stat 215A, Fall 2024</h1>
</div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">September 28, 2024</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>The study of language variation has long been a crucial area of linguistic research, offering valuable insights into the historical, social, and geographical factors that shape language use in society. Linguists have traditionally sought to understand how language varieties—such as dialects—are distributed across different regions and communities. A central question in twentieth-century dialectology concerns the analysis of geographic coherence in language variation: given the imperfect geographic boundaries of dialects, how should this variation be analyzed? Traditionally, dialectology has focused on identifying dialect areas, defined as regions with relatively limited internal linguistic variation, distinguishing them from neighboring areas.</p>
<p>However, the existence of such dialect areas, which we intuitively perceive, has proven difficult to demonstrate rigorously. Kretzschmar (1998) offers a potential explanation, differentiating between attributive dialects—linguistic varieties specific to a given place—and blind dialects, or areas whose distinctiveness cannot easily be captured by conventional methods. Field linguists can often catalog the linguistic features of a particular location, identifying an attributive dialect, but struggle to compare it meaningfully with varieties from other places. This challenge arises because traditional non-computational approaches typically analyze a small number of linguistic features, making it difficult to capture aggregate levels of variation.</p>
<p>Recent advances in computational techniques have transformed this landscape, enabling linguists to study language variation at scale. For example, simple techniques such as counting differences between linguistic features allowed Seguy to aggregate individual differences over large datasets. Other researchers, such as Speelman, Grondelaers, and Geeraerts, have utilized relative frequency analyses to measure variation, exploring how pairs of alternative lexical choices—such as <em>car</em> vs.&nbsp;<em>automobile</em> or <em>quiet</em> vs.&nbsp;<em>still</em>—can reveal deeper insights into linguistic differences. These frequency-based approaches, often referred to as linguistic profiles, have become essential tools in quantifying linguistic distance.</p>
<p>Building on these computational approaches, this paper explores the application of Principal Component Analysis (PCA) and clustering techniques for analyzing large-scale linguistic datasets. PCA is employed to reduce the dimensionality of the linguistic variables, capturing the most significant patterns of variation. Clustering methods, such as K-Means and Agglomerative Clustering, are then applied to group linguistic varieties based on their aggregate features. These techniques enable the identification of meaningful linguistic groupings and the exploration of dialect areas at a finer granularity than traditional methods. By incorporating computational tools like PCA and clustering, we hope to address longstanding challenges in dialectology, providing a more robust and scalable framework for analyzing language variation across regions.</p>
</section>
<section id="the-data" class="level1">
<h1>The Data</h1>
<p>The data are from a Dialect Survey conducted by Bert Vaux: https://www.dialectsofenglish.com/. The questions and answers was found and processed from the http://dialect.redlog.net/index.html by a past intrepid STAT215A student. The dataset contains the answers to the survey questions for 47, 471 respondents across the United States as well as the variables ID, CITY, STATE, ZIP, Q50 - Q121, lat and long. ID is a number identifying the respondent. CITY and STATE were self reported by respondents. Former GSIs found the latitude and longitude for the center of each zipcode and added the lat and long variables based on the reported city and state. Then the data was binned into one degree latitude by one degree longitude squares. In this paper, we will focus on the questions that look at lexical differences as opposed to phonetic differences, which are numbered 50-121.</p>
<section id="data-cleaning" class="level2">
<h2 class="anchored" data-anchor-id="data-cleaning">Data Cleaning</h2>
<p>In the dataset, “QXXX” are the responses to the corresponding question on the survey website. A value of 0 indicates no response. The other numbers should directly match the responses on the website, i.e.&nbsp;a value of 1 should match a response of (a). Data cleaning will drop rows with answers to 25 questions or more as “0”, which reduced the record from 47471 to 46136.</p>
</section>
<section id="exploratory-data-analysis" class="level2">
<h2 class="anchored" data-anchor-id="exploratory-data-analysis">Exploratory Data Analysis</h2>
<p>We picked two survey questions and investigate their relationship to each other and geography: what word do you use to refer ‘mow the lawn’ and what word do you use to refer ‘water fountain’? We created interactive maps to examine the geographical relationships. It seems “mow the lawn” and “cut the grass” are most common for the first question while “water fountain” and “drinking fountain” are most common for the second question. However, the popular answers do not define geopgraphical groups, as they spread across US. However, the infrequent answers (“mow the grass” and “bubbler”) seem to have a more distinct clusters (central and south US), consistent with Goebl’s observation when he assigned more heavy weightings which count overlap in infrequent words.</p>
<p><img src="./Users/lloydconnelly/stat-215-a/lab2/code/lab2_files/figure-html/1.png" class="img-fluid"></p>
<p><img src="./Users/lloydconnelly/stat-215-a/lab2/code/lab2_files/figure-html/2.png" class="img-fluid"></p>
<p>Next we explore if the answers to the two questions define any distinct geographical groups. Similarly to previous finding, the infrequent pair such as “mow the grass” and “bubbler” seem to form a cluster than the common phrases, based on the interactive map below.</p>
<p><img src="./Users/lloydconnelly/stat-215-a/lab2/code/lab2_files/figure-html/3.png" class="img-fluid"></p>
<p>We explore if a response to one question help predict the other by creating a contigency table and a heat map below, which confirms each other. The heatmap visualizes the relationship between responses to two different questions, Q100 (water fountain) and Q103 (mow the lawn). On the x-axis, we see the responses to Q103, and on the y-axis, the responses to Q100. The color intensity in the heatmap represents the frequency of respondents choosing each combination of answers for the two questions. The color bar on the right shows the frequency scale, where darker blue represents a higher number of respondents, and lighter shades represent fewer respondents. Darker squares indicate the most common response combinations between Q100 and Q103. “Water fountain” + “mow the lawn” is the most frequent combination, with 17,374 respondents answering these two options. This suggests that many people who use “water fountain” also prefer “mow the lawn.” “Drinking fountain” + “mow the lawn” is the second most common combination, with 9,925 respondents, indicates that “drinking fountain” is also often paired with “mow the lawn.”</p>
<div id="cell-22" class="cell" data-execution_count="151">
<div class="cell-output cell-output-stdout">
<pre><code>ans                 cut the grass   cut the lawn   mow the grass   \
ans                                                                 
bubbler                        320              8             115   
drinking fountain             3189             89            1067   
water bubbler                   26              1               5   
water fountain                5540            163            2079   
All                           9075            261            3266   

ans                 mow the lawn     All  
ans                                       
bubbler                      1098   1541  
drinking fountain            9925  14270  
water bubbler                  71    103  
water fountain              17374  25156  
All                         28468  41070  </code></pre>
</div>
</div>
<div id="cell-23" class="cell" data-execution_count="152">
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="lab2_files/figure-html/cell-15-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Quantitatively, we ran chi squared test which showed no significant association found between the responses to the two questions. See output below.</p>
<div id="cell-25" class="cell" data-execution_count="153">
<div class="cell-output cell-output-stdout">
<pre><code>Chi-squared Test Statistic: 12.7872682247342
P-value: 0.17247076692033975
No significant association found between the responses.</code></pre>
</div>
</div>
</section>
</section>
<section id="dimension-reduction" class="level1">
<h1>Dimension Reduction</h1>
<ul>
<li><p>This is where you discuss and show plots about the results of whatever dimension reduction techniques you tried—PCA, variants of PCA, t-SNE, NMF, random projections, etc.</p></li>
<li><p>What do you learn from your dimension reduction outputs</p></li>
<li><p>Discuss centering and scaling decisions It is very likely the two questions are not sufficient as features to characterize aggragate levels as discussed in Nerbonne et. al (2003). We are using all Q50-Q121 to see if that provide enough features. First step is to encode the data so that the response is binary instead of categorical. This makes p = 541 and n = 46,136. We used k instead of k-1 during the encoding. Next, we used PCA to reduce the dimensions. We started with PCA without scaling and plotted the PC1 and PC2 in 2-D. The dimension reduction didn’t seem to maximize the variance of the dataset in PC1 or PC2. Project PC1, PC2 and PC3 to 3-D space and issue persists.</p></li>
</ul>
<div id="cell-28" class="cell" data-execution_count="169">
<div class="cell-output cell-output-stdout">
<pre><code>Feature matrix shape: (46136, 535)</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="lab2_files/figure-html/cell-17-output-2.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<div id="cell-29" class="cell" data-execution_count="170">
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="lab2_files/figure-html/cell-18-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Next, we scaled the encoded dataset, ran PCA and projected the results to 2-D as shown below. The outcome has been significantly improved. Centering ensures that the principal components are computed based on the direction of maximum variance from the mean of the data. Scaling (standardizing to unit variance) is especially important if our features have different units or ranges. Without scaling, features with larger ranges could dominate the PCA, which may lead to incorrect results. However, in our case, scaling helped with our encoded dataset.</p>
<div id="cell-31" class="cell" data-execution_count="171">
<div class="cell-output cell-output-stdout">
<pre><code>Feature matrix shape: (46136, 535)</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="lab2_files/figure-html/cell-19-output-2.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>T-SNE was also experimented as a dimension reduction technique, with the encoded and scaled dataset. The dataset was projected onto the primary component and secondary component space as shown below. PCA with scaled data performs better than T-SNE in our case.</p>
<div id="cell-33" class="cell" data-execution_count="131">
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="lab2_files/figure-html/cell-20-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="clustering" class="level1">
<h1>Clustering</h1>
<p>After the dataset being projected on to PC1 and PC2 after PCA with scaled data, two different clustering methods are performed- K-means and Agglomerative Clustering. K=4 was selected using adjusted_rand_score as an evaluation mechanism, discussed in the Stability section. K-Means Clustering on PCA Projection is shownn below.</p>
<div id="cell-35" class="cell" data-execution_count="174">
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="lab2_files/figure-html/cell-21-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>We then added the K-means labels to the dataset and plot them on the interactive map below. Consistent with the previous discussion on “mow and lawn” and “water fountain”, the common label is widely spread across US while the blue and purple cluster seem to cluster in central/south US and east US. However, we cannot say the blue and purple clusters are completely isolated in a certain geographic area. There seems to be a continuum with a transition in density at central US.</p>
<p><img src="./Users/lloydconnelly/stat-215-a/lab2/code/lab2_files/figure-html/4.png" class="img-fluid"></p>
<p>We evaluated Which questions produce this continuum or separate the clusters by examing the PCA loading below, in descending order of the absolute value of PC1 weight. The top two weights are assigned to the answers to question 73, as shown below. Question 73 is about the word for “sneakers” or “tennis shoes”.</p>
<div id="cell-41" class="cell" data-execution_count="175">
<div class="cell-output cell-output-stdout">
<pre><code>             PC1       PC2
Q073_1  0.209652 -0.030818
Q073_6 -0.189739  0.033216
Q105_1  0.148928 -0.057069
Q080_1  0.147106 -0.020493
Q084_1  0.137032 -0.030482
Q093_2 -0.132329  0.001311
Q086_1  0.130709 -0.012003
Q066_5 -0.123389  0.026494
Q106_7  0.121860  0.002081
Q083_1  0.121532 -0.010367</code></pre>
</div>
</div>
<p>Agglomerative Clustering is also examed, as shown below. Agglomerative Clustering is a type of hierarchical clustering where clusters are formed by recursively merging smaller clusters. It starts with each data point as its own cluster and iteratively merges the closest clusters until all points are in one large cluster, or a predefined number of clusters is reached. This “bottom-up” approach contrasts with divisive clustering, which starts with all data points in a single cluster and splits them recursively. Agglomerative Clustering builds a hierarchy of clusters, and the results can be represented using a dendrogram—a tree-like diagram that shows the merging process. It is very computational expense compared to K-means clustering.</p>
<div id="cell-44" class="cell" data-execution_count="37">
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="lab2_files/figure-html/cell-26-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<div id="cell-45" class="cell" data-execution_count="176">
<div class="cell-output cell-output-display" data-execution_count="176">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">PC1</th>
<th data-quarto-table-cell-role="th">PC2</th>
<th data-quarto-table-cell-role="th">KMeans_Cluster</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>-0.861760</td>
<td>3.715114</td>
<td>0</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>5.163210</td>
<td>2.005029</td>
<td>1</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>4.562783</td>
<td>0.724209</td>
<td>1</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>4.446937</td>
<td>2.496730</td>
<td>1</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>4.212887</td>
<td>3.322333</td>
<td>1</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">46131</td>
<td>-1.778819</td>
<td>-0.378576</td>
<td>2</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">46132</td>
<td>-1.324144</td>
<td>0.055743</td>
<td>2</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">46133</td>
<td>-0.764036</td>
<td>-1.132271</td>
<td>2</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">46134</td>
<td>-0.695840</td>
<td>-1.154920</td>
<td>2</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">46135</td>
<td>1.119769</td>
<td>-1.624910</td>
<td>2</td>
</tr>
</tbody>
</table>

<p>46136 rows × 3 columns</p>
</div>
</div>
</div>
</section>
<section id="stability-of-findings-to-perturbation" class="level1">
<h1>Stability of findings to perturbation</h1>
<p>We analyzed the robustness of the clusters by bootstrap samping and evaluated the Adjusted Rand Index. After K-means clustering assigned the label for the original dataset and the bootstraped sample dataset, the labels for the same records are compared for consistency. The adjusted Rand Index approaching 1 means the results are consistent and the model is stable. We also used ARI to optimize k, the number of clusters. For k=2, 3 and 5, ARI is about 0.4; for k=4, using different starting point, ARI is consistenly between 0.96 and 0.98, see one instant below. Therefore we used k = 4 and the model is regarded as stable.</p>
<div id="cell-47" class="cell" data-execution_count="177">
<div class="cell-output cell-output-stdout">
<pre><code>Adjusted Rand Index: 0.9658040528630559</code></pre>
</div>
</div>
</section>
<section id="conclusion" class="level1">
<h1>Conclusion</h1>
<p>Using PCA as a dimension reduction technique and performing k-means clustering has derived some insights on using word choices to identify the geopgraphic regions where the respondents are located. However, common language associates with a shared culture and heritage which might not shared by people clustering physically, because people in US move frequently. Because of this limitation among others, I am not confident that we can use this model to predict the future data. If we have the opportunity to collect the data from the survey, I wonder if we can think of labels to identify the culture and social clusters for respondents to choose from, instead of using their physical location as a proxy.</p>
<p>As far as reality check, the challenges with PCA is that the new projections are hard to explain intuitively. However, the questions about “water foundation” and “mow the lawn” identified the frequent and infreqent choices of words, which seems to align with the reality. “Sneakers” vs “tennis shoes” also seems to be used by people from distinct regions.</p>
</section>
<section id="academic-honesty" class="level1">
<h1>Academic Honesty</h1>
<section id="statement" class="level2">
<h2 class="anchored" data-anchor-id="statement">Statement</h2>
<p>I affirm that the work presented in this report is my own, and I have not received unauthorized assistance from any individual or source. All external references and sources used have been appropriately cited and acknowledged, and I have followed the guidelines set forth by Prof.&nbsp;Yu regarding academic integrity and honesty. I understand that any violation of these principles may result in disciplinary action.</p>
</section>
<section id="llm-usage" class="level2">
<h2 class="anchored" data-anchor-id="llm-usage">LLM Usage</h2>
</section>
<section id="collaborators" class="level2">
<h2 class="anchored" data-anchor-id="collaborators">Collaborators</h2>
</section>
</section>
<section id="bibliography" class="level1">
<h1>Bibliography</h1>
<p>[1] John Nerbonne and William Kretzschmar. “Introducing computational techniques in dialectometry”. In: Computers and the Humanities 37 (2003), pp.&nbsp;245–255.</p>
<p>[2] John Nerbonne and William Kretzschmar. “Progress in dialectometry: toward explanation”. In: Literary and Linguistic Computing 21.4 (2006), pp.&nbsp;387–397.</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>